<?xml version="1.0" encoding="iso-8859-1" ?>

<AlgoNETExplorer>
    <StrategyCode StrategyName="BETA_Double Diagonal" Language="C# .NET">
        <TickEventCode>//
//
//
//------- D E S C R I P T I O N -------
//

//------- P E R F O R M A N C E   P A R A M E T E R S -------
Backtest.Configuration.UseWeekly = true;
Backtest.Configuration.UseQuarterly = false;
Backtest.Configuration.MaxExpirationDTE = 90;
Backtest.Configuration.CommissionRates.OptionPerContract = 1.0;

if(Backtest.UnderlyingSymbol == &quot;SPX&quot;) {
    Backtest.Configuration.PriceValidation.PositionConfirmationCount = 3;
    Backtest.Configuration.PriceValidation.PositionPercChange = 5;
}

//------- O P T I M I Z A T I O N   P A R A M E T E R S -------
int PARAM_FrontMonthMinDTE = 35;
int PARAM_FrontMonthMaxDTE = 36;
int PARAM_BackMonthMaxDTE = 28 + PARAM_FrontMonthMaxDTE;
int PARAM_BackMonthMinDTE = 28 + PARAM_FrontMonthMinDTE;
int PARAM_ProfitTarget = 10;
int PARAM_MaxLoss = 15;
int PARAM_ExitDTE = 5;
int PARAM_MaxAdjustments = 6;

//max underlying IV when initiating a trade
int PARAM_MaxUnderlyingIV = 12;

//roll spreads out at percentage of expiration breakeven
int PARAM_AdjustUpMoveLimit = 99;
int PARAM_AdjustDownMoveLimit = 99;

//width of call and put spreads
//note we well change the width of the call spread to 35 to cut deltas in the entry blocl
//if short deltas &gt; 3 when 50x40
int PARAM_CallDiagonalWidth = 20;
int PARAM_PutDiagonalWidth = 20;

//Where, in relation to current price of underlying, do we center the butterfly
int PARAM_FrontMonthCallDelta = 25;
int PARAM_FrontMonthPutDelta = 25;

//entry rules for market condition
double PARAM_UnderlyingMovementSDdown = -1.5;
double PARAM_UnderlyingMovementSDup = 1.5;
int PARAM_UnderlyingMovementSDDays = 3;

//max margin to use for trade
double PARAM_InitialMargin = 15000;
var PARAM_ScaleMargin = false;

//initiation day of month minimum and maximum
int PARAM_InitiationDayMinimum = 1;
int PARAM_InitiationDayMaximum = 31;

//Start and end window for taking trades
TimeSpan currentTime = Backtest.TradingDateTime.ToLocalTime().TimeOfDay; //Convert from UTC to localtime
TimeSpan startTime = new TimeSpan(8, 45, 0); //9:00 AM
TimeSpan endTime = new TimeSpan(14, 55, 0); //3:00 PM

//scalable margin - add 50% of PnL to size up
//but remove entire negative PnL if PnL is below 0
if(PARAM_ScaleMargin == true) {
    if(Backtest.Tag != null) {
        double addMargin =(double) Backtest.Tag;
        if(addMargin &gt; 0) {
            PARAM_InitialMargin = PARAM_InitialMargin +(addMargin / 2);
        } else {
            PARAM_InitialMargin = PARAM_InitialMargin +(addMargin);
        }
    }
    if(Backtest.TradingDateTime.ToLocalTime().TimeOfDay == startTime) WriteLog(&quot;PARAM_InitialxMargin=&quot; + PARAM_InitialMargin);
}

//work around backtest data problem for a specific date
TimeSpan startTime12202012 = new TimeSpan(12, 0, 0);
TimeSpan startTime10AM = new TimeSpan(10, 0, 0);

//minimum and maximum date of the month to enter a trade on
//year and month don&apos;t matter for us, because we will only use the .Day property
DateTime PARAM_InitiationDayMin = new DateTime(2000, 1, PARAM_InitiationDayMinimum);
DateTime PARAM_InitiationDayMax = new DateTime(2999, 12, PARAM_InitiationDayMaximum);

//log params at the beginning of the run
if(Backtest.TradingDateTime.ToLocalTime().TimeOfDay == startTime) {
    if(Backtest.TradeCount == 1) {
        WriteLog(&quot;-- BEGIN PARAMETERS ------------------------------------------&quot;);
		WriteLog(&quot;PARAM_FrontMonthMinDTE=&quot; + PARAM_FrontMonthMinDTE);
		WriteLog(&quot;PARAM_FrontMonthMaxDTE=&quot; + PARAM_FrontMonthMaxDTE);
		WriteLog(&quot;PARAM_BackMonthMaxDTE=&quot; + PARAM_BackMonthMaxDTE);
		WriteLog(&quot;PARAM_BackMonthMinDTE=&quot; + PARAM_BackMonthMinDTE);
		WriteLog(&quot;PARAM_ProfitTarget=&quot; + PARAM_ProfitTarget);
		WriteLog(&quot;PARAM_MaxLoss=&quot; + PARAM_MaxLoss);
		WriteLog(&quot;PARAM_ExitDTE=&quot; + PARAM_ExitDTE);
		WriteLog(&quot;PARAM_MaxAdjustments=&quot; + PARAM_MaxAdjustments);
		WriteLog(&quot;PARAM_MaxUnderlyingIV&quot; + PARAM_MaxUnderlyingIV);
		WriteLog(&quot;PARAM_AdjustUpMoveLimit=&quot; + PARAM_AdjustUpMoveLimit);
		WriteLog(&quot;PARAM_AdjustDownMoveLimit=&quot;+ PARAM_AdjustDownMoveLimit);
		WriteLog(&quot;PARAM_CallDiagonalWidth=&quot; + PARAM_CallDiagonalWidth);
		WriteLog(&quot;PARAM_PutDiagonalWidth=&quot; + PARAM_PutDiagonalWidth);
		WriteLog(&quot;PARAM_FrontMonthCallDelta=&quot; + PARAM_FrontMonthCallDelta);
		WriteLog(&quot;PARAM_FrontMonthPutDelta=&quot; + PARAM_PutDiagonalWidth);
        WriteLog(&quot;PARAM_ProfitTarget: &quot; + PARAM_ProfitTarget);
        WriteLog(&quot;PARAM_MaxLoss: &quot; + PARAM_MaxLoss);
        WriteLog(&quot;PARAM_MaxUnderlyingIV: &quot; + PARAM_MaxUnderlyingIV);
        WriteLog(&quot;PARAM_UnderlyingMovementSDdown: &quot; + PARAM_UnderlyingMovementSDdown);
        WriteLog(&quot;PARAM_UnderlyingMovementSDup: &quot; + PARAM_UnderlyingMovementSDup);
        WriteLog(&quot;PARAM_UnderlyingMovementSDDays: &quot; + PARAM_UnderlyingMovementSDDays);
        WriteLog(&quot;PARAM_UnderlyingMovementSDDays: &quot; + PARAM_UnderlyingMovementSDDays);
        WriteLog(&quot;startTime: &quot; + startTime + &quot; endTime: &quot; + endTime);
        WriteLog(&quot;-- END PARAMETERS ------------------------------------------&quot;);
    }
}
try {
	

    //there&apos;s something wrong with the backtest data on 01/04/2016
    if(Backtest.TradingDateTime.Date.ToString() == &quot;1/4/2016 12:00:00 AM&quot;) {
        if(currentTime &lt; startTime10AM) {
            return;
        }
    }

    //------- E N T R Y   R U L E S -------
    if(Position.IsOpen == false) {

        //reinitilize tag
        Position.Tag = null;

        // even though it is cheating, don&apos;t initiate any trades on 8/21/15 and 8/24/15
        // because pricing data on 8/24 is a mess and it really throw off the backtest
        if(Backtest.TradingDateTime.Date.ToString() == &quot;8/24/2015 12:00:00 AM&quot;) {
            WriteLog(&quot;Backtest.TradingDateTime.Date: &quot; + Backtest.TradingDateTime.Date.Date);
            return;
        }
        if(Backtest.TradingDateTime.Date.ToString() == &quot;8/21/2015 12:00:00 AM&quot;) {
            WriteLog(&quot;Backtest.TradingDateTime.Date: &quot; + Backtest.TradingDateTime.Date.Date);
            return;
        }

        //there&apos;s something wrong with the backtest data on 12/20/2012 until 11:00 AM
        if(Backtest.TradingDateTime.Date.ToString() == &quot;12/20/2012 12:00:00 AM&quot;) {
            if(currentTime &lt;= startTime12202012) {
                return;
            }
        }

        //there&apos;s something wrong with the backtest data on 8/1/2011 - 8/3/2011, don&apos;t initiate anything on those days
        if(Backtest.TradingDateTime.Date.ToString() == &quot;8/1/2011 12:00:00 AM&quot;) {
            return;
        }
        if(Backtest.TradingDateTime.Date.ToString() == &quot;8/2/2011 12:00:00 AM&quot;) {
            return;
        }
        if(Backtest.TradingDateTime.Date.ToString() == &quot;8/3/2011 12:00:00 AM&quot;) {
            return;
        }

        //if initiation week is set, then only initiate trades that week of the month
        //4th week includes days 28-31 as well
        if((Backtest.TradingDateTime.Day &gt;= PARAM_InitiationDayMin.Day) &amp;&amp;(Backtest.TradingDateTime.Day &lt;= PARAM_InitiationDayMax.Day)) {
            if(Backtest.TradingDateTime.ToLocalTime().TimeOfDay == startTime) WriteLog(&quot;Ok to take trades this week - Day=&quot; + Backtest.TradingDateTime.Day + &quot; Min=&quot; + PARAM_InitiationDayMin.Day + &quot; Max=&quot; + PARAM_InitiationDayMax.Day);
        } else {
            if(Backtest.TradingDateTime.ToLocalTime().TimeOfDay == startTime) WriteLog(&quot;NOT Ok to take trades this week - Day=&quot; + Backtest.TradingDateTime.Day + &quot; Min=&quot; + PARAM_InitiationDayMin.Day + &quot; Max=&quot; + PARAM_InitiationDayMax.Day);
            return;
        }

        //Check if underlying movement within entry SD limits
        double maxSDup = 0.0;
        double maxSDdown = 0.0;
        GetMaxSDMovement(PARAM_UnderlyingMovementSDDays, ref maxSDup, ref maxSDdown);
        if(maxSDup &gt; PARAM_UnderlyingMovementSDup) {
            //Check Time is 8:30 AM otherwise this logs every 5 min but SD value is static for the entire day
            if(Backtest.TradingDateTime.ToLocalTime().TimeOfDay == new TimeSpan(15, 00, 0)) { //Convert from UTC to localtime
                WriteLog(&quot;SD Up exceeded: maxSDup = &quot; + maxSDup);
                return; // Max SD on upside exceeded
            }
        }
        if(maxSDdown &lt; PARAM_UnderlyingMovementSDdown) {
            //Check Time is 8:30 AM otherwise this logs every 5 min but SD value is static for the entire day
            if(Backtest.TradingDateTime.ToLocalTime().TimeOfDay == new TimeSpan(15, 00, 0)) { //Convert from UTC to localtime
                WriteLog(&quot;SD Down exceeded: maxSDdown = &quot; + maxSDdown);
                return; // Max SD on downside exceeded
            }
        }

        //DO not initiate if the market is going haywire
        if(Underlying.IV &lt;= PARAM_MaxUnderlyingIV) {

            if((currentTime &gt;= startTime) &amp;&amp;(currentTime &lt;= endTime)) {

                //Find the month expiration cycle
                var frontMonthExpiration = GetExpiryByDTE(PARAM_FrontMonthMinDTE, PARAM_FrontMonthMaxDTE);
                var backMonthExpiration = GetExpiryByDTE(PARAM_BackMonthMinDTE, PARAM_BackMonthMaxDTE);
                if(frontMonthExpiration == null) {
					WriteLog(&quot;no front month option found between &quot; + PARAM_FrontMonthMinDTE + &quot; and &quot; + PARAM_FrontMonthMaxDTE + &quot; DTE&quot;);
					return; // Haven&apos;t found an expiration matching our criteria
				}
				if(backMonthExpiration == null) {
					WriteLog(&quot;no back month option found between &quot; + PARAM_BackMonthMinDTE + &quot; and &quot; + PARAM_BackMonthMaxDTE + &quot; DTE&quot;);
					return; // Haven&apos;t found an expiration matching our criteria
				}
				
                //Create a new Model Position and build an Iron Butterfly using the expiration cycles we found above.
                var modelPosition = NewModelPosition();
                var legShortPut = CreateModelLeg(SELL, 1, GetOptionByDelta(Put,-PARAM_FrontMonthPutDelta, frontMonthExpiration), &quot;ShortPut-&quot; + Position.Adjustments);
                modelPosition.AddLeg(legShortPut);
                var legLongPut = CreateModelLeg(BUY, 1, GetOptionByStrike(Put,(legShortPut.Strike - PARAM_PutDiagonalWidth), backMonthExpiration, true), &quot;LongPut-&quot; + Position.Adjustments);
                modelPosition.AddLeg(legLongPut);
                var legShortCall = CreateModelLeg(SELL, 1, GetOptionByDelta(Call,PARAM_FrontMonthCallDelta, frontMonthExpiration), &quot;ShortCall-&quot; + Position.Adjustments);
                modelPosition.AddLeg(legShortCall);
                var legLongCall = CreateModelLeg(BUY, 1, GetOptionByStrike(Call,(legShortCall.Strike + PARAM_CallDiagonalWidth), backMonthExpiration, true), &quot;LongCall-&quot; + Position.Adjustments);
                modelPosition.AddLeg(legLongCall);
              
                modelPosition.CommitTrade(&quot;Buy Double Diagonal 1 lot&quot;);

                //determine margin of a 1 lot so we can figure out how many lots to put on
                double nl = PARAM_InitialMargin / Position.Margin;
                int numLots =(int) nl;
                WriteLog(&quot;numLots: &quot; + numLots);
                var modelPosition2 = NewModelPosition();
                legShortPut = CreateModelLeg(SELL, numLots, GetOptionByStrike(Put,(legShortPut.Strike), frontMonthExpiration, true), &quot;ShortPut-&quot; + Position.Adjustments);
                modelPosition2.AddLeg(legShortPut);
                legLongPut = CreateModelLeg(BUY, numLots, GetOptionByStrike(Put,(legLongPut.Strike), backMonthExpiration, true), &quot;LongPut-&quot; + Position.Adjustments);
                modelPosition2.AddLeg(legLongPut);
                legShortCall = CreateModelLeg(SELL, numLots, GetOptionByStrike(Call,(legShortCall.Strike), frontMonthExpiration, true), &quot;ShortCall-&quot; + Position.Adjustments);
                modelPosition2.AddLeg(legShortCall);
                legLongCall = CreateModelLeg(BUY, numLots, GetOptionByStrike(Call,(legLongCall.Strike), backMonthExpiration, true), &quot;LongCall-&quot; + Position.Adjustments);
                modelPosition2.AddLeg(legLongCall);

                //Commit the Model Position to the Trade Log and add a comment
                modelPosition2.CommitTrade(&quot;Buy Double Diagonal number of lots: &quot; + numLots);
                WriteLog(&quot;Trade Entry - IV: &quot; + Underlying.IV);
				
				//now lets get our deltas flat to slightly positivie
				int deltas = (int) Position.Delta;
				if (deltas &lt; null) {
								
		            //Create a new Model Position
		            var modelPosition3=NewModelPosition(); 
                	legLongCall = CreateModelLeg(SELL, 1, GetOptionByStrike(Call,(legLongCall.Strike), backMonthExpiration, true), &quot;LongCall-&quot; + Position.Adjustments);
                	modelPosition3.AddLeg(legLongCall);
					var legNewLongCall = CreateModelLeg(BUY, 1, GetOptionByStrike(Call, Underlying.Last, backMonthExpiration, true), &quot;LongCall-&quot; + Position.Adjustments);
                	modelPosition3.AddLeg(legNewLongCall);

		            //Commit the Model Position to the Trade Log and add a comment
		            modelPosition3.CommitTrade(&quot;Flatten deltas&quot;);
					}
				}
        } else {
            WriteLog(&quot;Not initiating a trade because Underlying.IV = &quot; + Underlying.IV + &quot; and max is 25&quot;);
        }
    }
} catch(Exception ex) {
    WriteLog(&quot;Try/Catch hit in initiation block&quot;);
}

//------- A D J U S T M E N T   R U L E S -------
//

try {
	int deltas = (int) Position.Delta;
	WriteLog(&quot;Position Deltas=&quot; + deltas);
	
	//upside adjustment
	var longCalls = Position.GetLegByName(&quot;LongCall*&quot;);
	var shortCalls = Position.GetLegByName(&quot;ShortCall*&quot;);
	var longPuts = Position.GetLegByName(&quot;LongPut*&quot;);
	var shortPuts = Position.GetLegByName(&quot;ShortPut*&quot;);
	int callWidth = (int) longCalls.Strike - (int) shortCalls.Strike;
	WriteLog(&quot;Call width=&quot; + callWidth);
	int putWidth = (int) shortPuts.Strike - (int) longPuts.Strike;
	WriteLog(&quot;Put width=&quot; + putWidth);
	int deltaAdd = (deltas / longCalls.Qty);
	int deltaSubtract = ((deltas / longPuts.Qty)/2);
	var backMonthExpiration = GetExpiryByDTE(Position.GetLegByName(&quot;LongCall*&quot;).DTE);
	if (deltas &lt; (longCalls.Qty * -10)) 
		{
		WriteLog(&quot;deltas &lt; (longCalls.Qty * -10)&quot;);
		WriteLog(deltas + &quot;&lt;&quot; + (longCalls.Qty * -10));
	
		if (putWidth &lt; 20) {
		//Roll puts back if we&apos;ve narrowed put width
            var modelPosition=NewModelPosition(); 
        	var closingLeg=longPuts.CreateClosingModelLeg();
			modelPosition.AddLeg(closingLeg);
			WriteLog(&quot;Put delta &quot; + longPuts.Delta + &quot; deltas to subtract &quot; + deltaSubtract + &quot; new delta is &quot; + (longPuts.Delta - deltaSubtract));
			var legLongPut = CreateModelLeg(BUY, longPuts.Qty, GetOptionByDelta(Put, (longPuts.Delta - deltaSubtract), backMonthExpiration), &quot;LongPut-&quot; + Position.Adjustments);
        	modelPosition.AddLeg(legLongPut);

            //Commit the Model Position to the Trade Log and add a comment
            modelPosition.CommitTrade(&quot;Roll Long Puts Back Down&quot;);
	    } else {
		 //else roll calls up
            var modelPosition=NewModelPosition(); 
        	var closingLeg=longCalls.CreateClosingModelLeg();
			modelPosition.AddLeg(closingLeg);
			var legLongCall = CreateModelLeg(BUY, longCalls.Qty, GetOptionByDelta(Call, (longCalls.Delta - deltaAdd), backMonthExpiration), &quot;LongCall-&quot; + Position.Adjustments);
        	modelPosition.AddLeg(legLongCall);

            //Commit the Model Position to the Trade Log and add a comment
            modelPosition.CommitTrade(&quot;Roll Long Calls&quot;);
	    }
	}
	
	//downside adjustment

	backMonthExpiration = GetExpiryByDTE(Position.GetLegByName(&quot;LongPut*&quot;).DTE);
	if (deltas &gt; (longPuts.Qty * 10)) 
		{
		WriteLog(&quot;deltas &gt; (longPuts.Qty * 10)&quot;);
		WriteLog(deltas + &quot;&gt;&quot; + (longPuts.Qty * 10));
		
		if (callWidth &lt; 20) {
		
		 //Roll calls back if we&apos;ve narrowed put width
            var modelPosition=NewModelPosition(); 
        	var closingLeg=longCalls.CreateClosingModelLeg();
			modelPosition.AddLeg(closingLeg);
			var legLongCall = CreateModelLeg(BUY, longCalls.Qty, GetOptionByDelta(Call, (longCalls.Delta - deltaAdd), backMonthExpiration), &quot;LongCall-&quot; + Position.Adjustments);
        	modelPosition.AddLeg(legLongCall);

            //Commit the Model Position to the Trade Log and add a comment
            modelPosition.CommitTrade(&quot;Roll Long Calls Back Up&quot;);
			
	    } else {
				
		 //else roll puts up
            var modelPosition=NewModelPosition(); 
        	var closingLeg=longPuts.CreateClosingModelLeg();
			modelPosition.AddLeg(closingLeg);
			WriteLog(&quot;Put delta &quot; + longPuts.Delta + &quot; deltas to subtract &quot; + deltaSubtract + &quot; new delta is &quot; + (longPuts.Delta - deltaSubtract));
			var legLongPut = CreateModelLeg(BUY, longPuts.Qty, GetOptionByDelta(Put, (longPuts.Delta - deltaSubtract), backMonthExpiration), &quot;LongPut-&quot; + Position.Adjustments);
        	modelPosition.AddLeg(legLongPut);

            //Commit the Model Position to the Trade Log and add a comment
            modelPosition.CommitTrade(&quot;Roll Long Puts&quot;);
	    }
	}

} catch(Exception ex) {
    WriteLog(&quot;Try/Catch hit in adjustment block&quot;);
}
	
//------- E X I T   R U L E S -------
try {
    if(Position.IsOpen == true) {

        if((currentTime &gt;= startTime) &amp;&amp;(currentTime &lt;= endTime)) {

            double PnL = 0;
            if(Backtest.Tag != null) { PnL =(double) Backtest.Tag; }

            //Check Profit Target
            if(Position.PnL &gt;=((PARAM_InitialMargin * PARAM_ProfitTarget) / 100)) {
                Position.Close(&quot;Hit Profit Target&quot;);
                Backtest.Tag = PnL + Position.PnL - Position.Commission;
                WriteLog(&quot;Backtest.Tag=&quot; + Backtest.Tag);
                WriteLog(&quot;Position.PnL=&quot; + Position.PnL);
            }

            //Check Max Loss
            if(Position.PnL &lt;=((PARAM_InitialMargin * -PARAM_MaxLoss) / 100)) {
                Position.Close(&quot;Hit Max Loss&quot;);
                Backtest.Tag = PnL + Position.PnL - Position.Commission;
                WriteLog(&quot;Backtest.Tag=&quot; + Backtest.Tag);
                WriteLog(&quot;Position.PnL=&quot; + Position.PnL);
            }

            //Check Minimum DTE
            if(Position.DTE &lt;= PARAM_ExitDTE) {
                Position.Close(&quot;Hit Minimum DTE&quot;);
                Backtest.Tag = PnL + Position.PnL - Position.Commission;
                WriteLog(&quot;Backtest.Tag=&quot; + Backtest.Tag);
                WriteLog(&quot;Position.PnL=&quot; + Position.PnL);
            }

            //Check Max Adjustments
            if(Position.Adjustments &gt;= PARAM_MaxAdjustments) {
                Position.Close(&quot;Hit Max Adjustments&quot;);
                Backtest.Tag = PnL + Position.PnL - Position.Commission;
                WriteLog(&quot;Backtest.Tag=&quot; + Backtest.Tag);
                WriteLog(&quot;Position.PnL=&quot; + Position.PnL);
            }

			//exit at Expiration BE
			//don&apos;t want this being triggered to to sag in the middle, so only beyond our longs
			if (Underlying.Last &gt;  Position.GetLegByName(&quot;LongCall*&quot;).Strike) {
				if (Underlying.Last &lt; Position.Expiration().LowerBE) {
					Position.Close(&quot;Hit Lower BE&quot;);
	                Backtest.Tag = PnL + Position.PnL - Position.Commission;
	                WriteLog(&quot;Backtest.Tag=&quot; + Backtest.Tag);
	                WriteLog(&quot;Position.PnL=&quot; + Position.PnL);
				}
			}
			if (Underlying.Last &lt;  Position.GetLegByName(&quot;LongPut*&quot;).Strike) {
				if (Underlying.Last &gt; Position.Expiration().UpperBE) {
					Position.Close(&quot;Hit Upper BE&quot;);
	                Backtest.Tag = PnL + Position.PnL - Position.Commission;
	                WriteLog(&quot;Backtest.Tag=&quot; + Backtest.Tag);
	                WriteLog(&quot;Position.PnL=&quot; + Position.PnL);
				}
			}
			
            // even though it is cheating, don&apos;t initiate any trades on 8/21/15 and 8/24/15
            // because pricing data on 8/24 is a mess and it really throw off the backtest
            if(Backtest.TradingDateTime.Date.ToString() == &quot;8/24/2015 12:00:00 AM&quot;) {
                Position.Close(&quot;8/24/2015 data problem&quot;);
                return;
            }
            if(Backtest.TradingDateTime.Date.ToString() == &quot;8/21/2015 12:00:00 AM&quot;) {
                Position.Close(&quot;8/21/2015 data problem&quot;);
                return;
            }
			
            //this is an ugly workaround for some data problem on 8-2-11 and 8-3-11 that causes my adjustment/exti rules to not be applied
            //we&apos;re just closing the trade before the data problems begin 
            if(Backtest.TradingDateTime.Date.ToString() == &quot;8/1/2011 12:00:00 AM&quot;) {
                WriteLog(&quot;Closing due to rule for 8/1/2011&quot;);
                Position.Close(&quot;Failed to lookup adjustment options - WORKAROUND for 8/1/2011, just exit&quot;);
            }
        }
		
    }
} catch(Exception ex) {
    WriteLog(&quot;Try/Catch hit in adjustment block&quot;);
}</TickEventCode>
    </StrategyCode>
</AlgoNETExplorer>
